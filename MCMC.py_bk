import numpy as np
from scipy.stats import uniform, norm, gamma, multivariate_t, t
import matplotlib.pyplot as plt
import matplotlib
import os

def normal_loglike(mean, err_pr, x):
    """ Compute the log likelihood of an N dimensional normal
    distribution at location x

    Parameters:
        - mean: ndarray (1 x N), mean of distribution
        - err_pr: error precision, either a scalar
                  or symmetric positive-definite matrix
        - x:  ndarray (1 x N), where likelihood is being evaluated
    """

    N = len(x)
    err_pr = np.atleast_1d(err_pr)
    err_pr_mat = np.diag(np.repeat(err_pr, N))
    Z = -N * np.log(2*np.pi) + sum(np.log(np.diag(err_pr_mat)))

    loglike = 0.5 * (Z - (x - mean) @ err_pr_mat @\
        (x - mean).T)
    return loglike.squeeze()


def unnorm_log_post(data, mu, delta2, mu_prior, delta2_prior, likelihood_dist='normal', tdf=None, tdf_prior=None):

    # calculate log prior
    ndelta = len(delta2_prior)
    delta2_logprior = [delta2_prior[i].logpdf(delta2[i]) for i in np.arange(ndelta)]
    if likelihood_dist == 't':
        if tdf_prior is None:
            raise ValueError('Must provide a prior distribution for tdf')
        tdf_logprior = [tdf_prior[i].logpdf(tdf[i]) for i in np.arange(ndelta)]
        log_prior = mu_prior.logpdf(mu) + np.sum(delta2_logprior) + np.sum(tdf_logprior)
    else:
        log_prior = mu_prior.logpdf(mu) + np.sum(delta2_logprior)

    nS = len(data)

    # calculate the log likelihood
    if likelihood_dist == 'normal':

        if ndelta == 1:
            log_like_sample1 = normal_loglike(mu[0], delta2[0], data[0])
            log_like_sample2 = normal_loglike(mu[1], delta2[0], data[1])
        elif ndelta > 1:
            log_like_sample1 = normal_loglike(mu[0], delta2[0], data[0])
            log_like_sample2 = normal_loglike(mu[1], delta2[1], data[1])
        log_like = log_like_sample1 + log_like_sample2

    elif likelihood_dist == 't':

        if tdf is None:
            raise ValueError('Must provide degrees of freedom for t distribution')

        N = [len(data[i]) for i in np.arange(nS)]
        if ndelta == 1:
            var = 1/delta2[0]
            log_like_sample1 = np.sum(t.logpdf(data[0], df=tdf[0], loc=mu[0], scale=np.sqrt(var[0])))
            log_like_sample2 = np.sum(t.logpdf(data[1], df=tdf[0], loc=mu[1], scale=np.sqrt(var[0])))
        elif ndelta > 1:
            var = [1/delta2[i] for i in np.arange(nS)]
            log_like_sample1 = np.sum(t.logpdf(data[0], df=tdf[0], loc=mu[0], scale=np.sqrt(var[0])))
            log_like_sample2 = np.sum(t.logpdf(data[1], df=tdf[1], loc=mu[1], scale=np.sqrt(var[1])))
        log_like = log_like_sample1 + log_like_sample2

    else:
        raise ValueError(f'{likelihood_dist} likelihood not yet implemented')

    return log_like + log_prior



def MCMC(data, priors, nsamples=100_000, burnin=10_000, cov_check=2_000,
    sampler='metropolis_hastings', prop_var=100, theta_0=None,
    diagnostic_check=20_000, iter_start_diag=10_000, figdir=None,
    likelihood_dist='normal'):

    MCMC_dir = f"{figdir}/MCMC"
    if not os.path.exists(MCMC_dir):
        os.makedirs(MCMC_dir)

    if iter_start_diag < burnin:
        iter_start_diag = burnin

    target_accept = np.array([0.2, 0.5])
    nS = len(data)

    # chain initiation point
    if likelihood_dist == 'normal' or likelihood_dist == 't':
        mu_0 = priors.mu.rvs()
        ndelta = len(priors.delta2)
        delta2_0 = np.asarray([0.001 for i in np.arange(ndelta)])
        while False:
            delta2_0 = [priors.delta2[i].rvs() for i in np.arange(ndelta)]
            if np.all(delta2_0) != 0:
                break
        curr_pars = np.hstack(([mu_0.copy(), delta2_0.copy()]))
        if likelihood_dist == 't':
            tdf_0 = [15 for i in np.arange(ndelta)]
            #curr_tdf = tdf_0.copy()
            curr_pars = np.hstack(([mu_0.copy(), delta2_0.copy(), tdf_0.copy()]))
        block_idx = {}
        block_idx[0] = [0, 1]
    elif likelihood_dist == 'weibull':
        sig_0 = priors.sig0.rvs()
        rho_0 = priors.rho.rvs()
        curr_pars = np.array(([sig_0.copy(), rho_0.copy()]))
        block_idx[0] = [0, 1]
        block_idx[1] = [2, 3]

    D = len(curr_pars)
    mcmc_chain = np.zeros((nsamples, D))
#    mu_chain = np.zeros((nsamples, D))
#    curr_mu  = mu_0.copy()
#    curr_delta2 = delta2_0.copy()
#    D = len(curr_mu)

    prop_var = np.atleast_1d(np.asarray(prop_var))
    prop_var = np.repeat(prop_var[0], D)

    delta2_chain = np.zeros((nsamples, ndelta))
    log_post = np.zeros(nsamples)

    if likelihood_dist == 't':
        delta_prop_var = [.001 for i in np.arange(ndelta)]
        acceptance_delta2 = np.zeros((nsamples, ndelta))
        tdf_prop_var = [10 for i in np.arange(ndelta)]
        acceptance_tdf = np.zeros((nsamples, ndelta))
        tdf_chain = np.zeros((nsamples, ndelta))

    # track paramter acceptance rate for each parameter
    acceptance = np.zeros(nsamples)

    # initial log posterior calculation
    if likelihood_dist == 'normal':
        initial_logpost = unnorm_log_post(data, mu_0, delta2_0, mu_prior,
            delta2_prior, likelihood_dist=likelihood_dist)
    elif likelihood_dist == 't':
        initial_logpost = unnorm_log_post(data, mu_0, delta2_0, mu_prior,
            delta2_prior, likelihood_dist=likelihood_dist, tdf=tdf_0, tdf_prior=tdf_prior)
    curr_post = initial_logpost


    for sample in range(nsamples):

        if np.mod(sample, 1000) == 0 :
            print(f"sample = {sample}")

        # covariance adaptation
        if np.mod(sample, cov_check) == 0 and sample > 0 and sample < burnin:
            accept_rate = (1 + acceptance[sample - cov_check : sample-1].sum(axis=0)) / cov_check
            print(f"Accept rate for mu: {accept_rate}")
            if accept_rate < target_accept[0] or accept_rate > target_accept[1]:
                prop_var = prop_var * accept_rate / \
                   (target_accept[0] + np.ptp(target_accept) / 2)
            if likelihood_dist == 't':
                delta2_accept_rate = (1 + acceptance_delta2[sample - cov_check : sample-1, ...].sum(axis=0)) / cov_check
                print(f"Accept rate for delta2: {delta2_accept_rate}")
                tdf_accept_rate = (1 + acceptance_tdf[sample - cov_check : sample-1, ...].sum(axis=0)) / cov_check
                print(f"Accept rate for tdf: {tdf_accept_rate}")
                for dd in np.arange(ndelta):
                    if delta2_accept_rate[dd] < target_accept[0] or delta2_accept_rate[dd] > target_accept[1]:
                        delta_prop_var[dd] = delta_prop_var[dd] * delta2_accept_rate[dd] / \
                           (target_accept[0] + np.ptp(target_accept) / 2)
                    if tdf_accept_rate[dd] < target_accept[0] or tdf_accept_rate[dd] > target_accept[1]:
                        tdf_prop_var[dd] = tdf_prop_var[dd] * tdf_accept_rate[dd] / \
                           (target_accept[0] + np.ptp(target_accept) / 2)

        # sample a new theta from proposal distribution
        prop_mu = norm(curr_mu, prop_var ** 0.5).rvs()

        if likelihood_dist == 'normal':
            prop_post = unnorm_log_post(data, prop_mu, curr_delta2, mu_prior,
            delta2_prior, likelihood_dist=likelihood_dist)
        elif likelihood_dist == 't':
            prop_post = unnorm_log_post(data, prop_mu, curr_delta2, mu_prior,
            delta2_prior, likelihood_dist=likelihood_dist, tdf=curr_tdf, tdf_prior=tdf_prior)

        if np.log(uniform(0,1).rvs(1)) < prop_post - curr_post:
            curr_mu = prop_mu.copy()
            curr_post = prop_post.copy()
            acceptance[sample] = 1
        else:
            acceptance[sample] = 0

        if likelihood_dist == 'normal':

            # gibbs step for delta (the precision of the distribution)
            for dd in np.arange(ndelta):
                alpha = delta2_prior[dd].args[0]
                beta = 1 / delta2_prior[dd].kwds['scale']
                if ndelta == 1: # same delta2 for both distributions
                    N = [len(data[i]) for i in np.arange(nS)]
                    full_cond_shape = sum(N)/2 + alpha
                    diff = [data[i] - curr_mu[i] for i in np.arange(nS)]
                    sum_sq_diff = [np.sum(diff[i] ** 2) for i in np.arange(nS)]
                    full_cond_rate = beta + 1/2 * np.sum(sum_sq_diff)
                    curr_delta2 = [gamma(full_cond_shape, scale=1/full_cond_rate).rvs()]
                elif ndelta > 1: # different delta2 for each distribution
                    N = len(data[dd])
                    full_cond_shape = N * 1 / 2 + alpha
                    diff = data[dd] - curr_mu[dd]
                    sum_sq_diff = np.sum(diff ** 2)
                    full_cond_rate = beta + 1/2 * sum_sq_diff
                    curr_delta2[dd] = gamma(full_cond_shape, scale=1/full_cond_rate).rvs()
            curr_post = unnorm_log_post(data, curr_mu, curr_delta2, mu_prior,
                delta2_prior, likelihood_dist=likelihood_dist)
 
        elif likelihood_dist == 't':

            # MH step for delta
            for dd in np.arange(ndelta):
                prop_delta2 = curr_delta2.copy()
                while True:
                    prop_delta2[dd] = norm(curr_delta2[dd], delta_prop_var[dd] ** 0.5).rvs()
                    if prop_delta2[dd] > 0:
                        break

                prop_post = unnorm_log_post(data, curr_mu, prop_delta2, mu_prior,
                    delta2_prior, likelihood_dist=likelihood_dist, tdf=curr_tdf, tdf_prior=tdf_prior)

                if np.log(uniform(0,1).rvs(1)) < prop_post - curr_post:
                    curr_delta2[dd] = prop_delta2[dd].copy()
                    curr_post = prop_post.copy()
                    acceptance_delta2[sample, dd] = 1
                else:
                    acceptance_delta2[sample, dd] = 0

                # MH step for tdf
                prop_tdf = curr_tdf.copy()
                while True:
                    prop_tdf[dd] = norm(curr_tdf[dd], tdf_prop_var[dd] ** 0.5).rvs()
                    if prop_tdf[dd] >= 1 and prop_tdf[dd] <= 30:
                        break

                prop_post = unnorm_log_post(data, curr_mu, curr_delta2, mu_prior,
                    delta2_prior, likelihood_dist=likelihood_dist, tdf=prop_tdf, tdf_prior=tdf_prior)

                if np.log(uniform(0,1).rvs(1)) < prop_post - curr_post:
                    curr_tdf[dd] = prop_tdf[dd].copy()
                    curr_post = prop_post.copy()
                    acceptance_tdf[sample, dd] = 1
                else:
                    acceptance_tdf[sample, dd] = 0

        mu_chain[sample] = curr_mu
        delta2_chain[sample] = curr_delta2
        log_post[sample] = curr_post
        if likelihood_dist == 't':
            tdf_chain[sample] = curr_tdf

        if np.mod(sample+1, diagnostic_check) == 0 and sample > iter_start_diag:
            trace = {}
            trace['mu'] = mu_chain
            trace['delta2'] = delta2_chain
            trace['log_post'] = log_post
            if likelihood_dist == 't':
                trace['tdf'] = tdf_chain

            plt.figure(figsize=(12,8))
            plt.subplot(1, 2, 1)
            plt.plot(mu_chain[iter_start_diag:sample, 0])
            plt.title(r'Trace $\mu_1$')
            plt.subplot(1, 2, 2)
            plt.plot(mu_chain[iter_start_diag:sample, 1])
            plt.title(r'Trace $\mu_2$')
            plt.savefig(f"{MCMC_dir}/mu_trace_iter_{sample+1}.png")
            plt.close()

            if likelihood_dist == 't':
                plt.figure(figsize=(12,8))
                plt.subplot(1, ndelta, 1)
                plt.plot(tdf_chain[iter_start_diag:sample, 0])
                plt.title(r'Trace $df_{1}$')
                if ndelta == 2:
                    plt.subplot(1, ndelta, 2)
                    plt.plot(tdf_chain[iter_start_diag:sample, 1])
                    plt.title(r'Trace $df_{2}$')
                plt.savefig(f"{MCMC_dir}/tdf_trace_iter_{sample+1}.png")
                plt.close()

            plt.figure(figsize=(12,8))
            plt.subplot(1, ndelta, 1)
            plt.plot(delta2_chain[iter_start_diag:sample, 0])
            plt.title(r'Trace $\delta^2_1$')
            if ndelta == 2:
                plt.subplot(1, ndelta, 2)
                plt.plot(delta2_chain[iter_start_diag:sample, 1])
                plt.title(r'Trace $\delta^2_2$')
            plt.savefig(f"{MCMC_dir}/delta_trace_iter_{sample+1}.png")
            plt.close()

            plt.figure(figsize=(12,8))
            plt.plot(log_post[iter_start_diag:sample])
            plt.title(r'Log $\pi(\theta | y)$')
            plt.savefig(f"{MCMC_dir}/logpost_iter_{sample+1}.png")
            plt.close()

    trace = {}
    trace['mu'] = mu_chain
    trace['delta2'] = delta2_chain
    trace['log_post'] = log_post
    if likelihood_dist == 't':
        trace['tdf'] = tdf_chain
    return trace, prop_var


